<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dota 2 Team Balancer</title>
  <style>
    body {
      margin: 0;
      font-family: 'Arial', sans-serif;
      overflow-x: hidden;
      color: white;
    }
    .background {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: url('dota2-background.gif') center/cover no-repeat;
      filter: blur(3px) brightness(0.7);
      z-index: 0;
    }
    .overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 1;
    }
    .container {
      position: relative;
      z-index: 2;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
    }
    .form-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
      align-items: center;
    }
    input {
      padding: 10px;
      font-size: 1rem;
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      border-radius: 4px;
    }
    input::placeholder {
      color: rgba(255,255,255,0.7);
    }
    button {
      padding: 10px 15px;
      cursor: pointer;
      background: #4a5568;
      color: white;
      border: none;
      border-radius: 4px;
      font-weight: bold;
      transition: all 0.2s;
    }
    button:hover {
      background: #2d3748;
      transform: translateY(-1px);
    }
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .tab {
      padding: 10px 15px;
      background: rgba(255,255,255,0.1);
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
      font-weight: bold;
    }
    .tab:hover {
      background: rgba(255,255,255,0.2);
    }
    .active-tab {
      background: #4299e1;
      font-weight: bold;
    }
    .team {
      margin: 20px 0;
      padding: 15px;
      background: rgba(0,0,0,0.4);
      border-radius: 10px;
      min-height: 150px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .player {
      padding: 8px 12px;
      margin: 5px 0;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.2s;
    }
    .player:hover {
      transform: translateX(3px);
    }
    .red { background-color: rgba(239, 68, 68, 0.8); }
    .yellow { background-color: rgba(234, 179, 8, 0.8); color: #000; }
    .green { background-color: rgba(34, 197, 94, 0.8); }
    .banned { 
      background-color: rgba(0,0,0,0.8);
      color: white;
      font-weight: bold;
      border: 1px solid #f00;
    }
    .queue-container {
      margin-top: 30px;
      background: rgba(0,0,0,0.4);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .queue-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .queue-content {
      max-height: 300px;
      overflow-y: auto;
    }
    .search-container {
      margin: 15px 0;
    }
    #playerSearch {
      width: 250px;
      padding: 10px;
      background: rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.2);
    }
    .player-list {
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      max-height: 500px;
      overflow-y: auto;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .player-list-item {
      padding: 10px;
      margin: 5px 0;
      cursor: pointer;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255,255,255,0.05);
      transition: all 0.2s;
    }
    .player-list-item:hover {
      background: rgba(255, 255, 255, 0.15);
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 100;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background: #1a202c;
      padding: 25px;
      border-radius: 10px;
      width: 350px;
      max-width: 90%;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
    .modal-content input, .modal-content textarea {
      width: 100%;
      padding: 10px;
      margin: 8px 0;
      background: rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.2);
      color: white;
      border-radius: 4px;
    }
    .modal-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
      gap: 10px;
    }
    .modal-buttons button {
      padding: 10px 15px;
      flex: 1;
    }
    button.danger {
      background-color: #e53e3e;
      color: white;
    }
    button.danger:hover {
      background-color: #c53030;
    }
    button.success {
      background-color: #48bb78;
      color: white;
    }
    button.success:hover {
      background-color: #38a169;
    }
    .team.highlight {
      background: rgba(255, 255, 255, 0.1);
      transition: background 0.2s;
    }
    .player-status {
      font-size: 0.9em;
      margin-left: 8px;
      color: white;
      opacity: 0.9;
    }
    .status-queue { color: #a0aec0; }
    .status-team1 { color: #fc8181; }
    .status-team2 { color: #68d391; }
    .status-lobby1 { color: #63b3ed; }
    .status-lobby2 { color: #f6ad55; }
    .status-lobby3 { color: #b794f4; }
    .filter-options {
      margin: 15px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
    }
    .filter-options label {
      display: flex;
      align-items: center;
      gap: 5px;
      cursor: pointer;
      font-size: 0.95em;
    }
    .queue-player-actions {
      display: flex;
      gap: 8px;
    }
    .team-count {
      font-size: 0.9em;
      opacity: 0.9;
      margin-left: 10px;
    }
    .suggestions {
      position: absolute;
      background: #2d3748;
      border: 1px solid #4a5568;
      max-height: 200px;
      overflow-y: auto;
      z-index: 10;
      width: calc(100% - 16px);
      max-width: 300px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    .suggestion-item {
      padding: 10px;
      cursor: pointer;
      transition: all 0.1s;
    }
    .suggestion-item:hover {
      background: #4a5568;
    }
    .team-stats {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
      font-size: 0.95em;
      flex-wrap: wrap;
      gap: 10px;
    }
    .team-stat {
      background: rgba(0,0,0,0.3);
      padding: 5px 10px;
      border-radius: 4px;
    }
    .player-actions {
      display: flex;
      gap: 8px;
    }
    .sort-options {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0;
    }
    .sort-btn {
      padding: 6px 12px;
      font-size: 0.85em;
      background: rgba(255,255,255,0.1);
    }
    .sort-btn.active {
      background: #4299e1;
    }
    h1, h2, h3 {
      color: white;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    h1 {
      margin-top: 0;
      font-size: 2.2em;
    }
    h2 {
      font-size: 1.8em;
    }
    h3 {
      font-size: 1.4em;
      display: flex;
      align-items: center;
    }
    .teams {
      display: flex;
      gap: 20px;
    }
    @media (max-width: 768px) {
      .form-group {
        flex-direction: column;
        align-items: stretch;
      }
      .teams {
        flex-direction: column;
      }
      .team-stats {
        flex-direction: column;
      }
      .player-actions {
        flex-direction: column;
      }
      input {
        width: 100%;
      }
      .modal-buttons {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="background"></div>
  <div class="overlay"></div>
  <div class="container">
    <div class="tabs">
      <div class="tab active-tab" onclick="switchLobby(0)">Lobby 1</div>
      <div class="tab" onclick="switchLobby(1)">Lobby 2</div>
      <div class="tab" onclick="switchLobby(2)">Lobby 3</div>
      <div class="tab" onclick="showAllPlayersPage()">All Players</div>
    </div>

    <div id="mainPage">
      <h1>Dota 2 Team Balancer</h1>
      <div class="form-group">
        <div style="position: relative;">
          <input type="text" id="name" placeholder="Nickname" oninput="showPlayerSuggestions()">
          <div class="suggestions" id="playerSuggestions" style="display: none;"></div>
        </div>
        <input type="number" id="mmr" placeholder="Rating (MMR)">
        <input type="number" id="bhv" placeholder="BHV (0-12000)">
        <input type="text" id="friendId" placeholder="Friend ID">
        <button onclick="addToQueue()">Add to Queue</button>
        <button onclick="moveAllToLobby()">Move All to Lobby</button>
        <button onclick="clearCurrentLobby()" class="danger">Clear Current Lobby</button>
      </div>

      <div class="teams">
        <div class="team" id="team1" ondragover="allowDrop(event)" ondrop="drop(event, 'team1')" ondragleave="clearHighlight(event)">
          <h3>Team 1 <span class="team-count">(<span id="team1Count">0</span>/5)</span></h3>
          <div id="team1Players"></div>
          <div class="team-stats" id="team1Stats"></div>
        </div>
        <div class="team" id="team2" ondragover="allowDrop(event)" ondrop="drop(event, 'team2')" ondragleave="clearHighlight(event)">
          <h3>Team 2 <span class="team-count">(<span id="team2Count">0</span>/5)</span></h3>
          <div id="team2Players"></div>
          <div class="team-stats" id="team2Stats"></div>
        </div>
      </div>

      <div class="form-group">
        <button onclick="balanceTeams()">Balance Teams</button>
      </div>

      <div class="queue-container">
        <div class="queue-header">
          <h3>Global Queue <span class="team-count">(<span id="queueCount">0</span>)</span></h3>
          <div>
            <button onclick="createBestLobby()" style="margin-right: 10px;">Create Best Lobby</button>
            <button onclick="clearQueue()" class="danger">Clear Queue</button>
          </div>
        </div>
        <div class="queue-content" id="waitingList" ondragover="allowDrop(event)" ondrop="drop(event, 'queue')" ondragleave="clearHighlight(event)">
          <!-- Queue content will be rendered here -->
        </div>
      </div>
    </div>

    <div id="allPlayersPage" style="display: none;">
      <h1>All Players</h1>
      <div class="search-container">
        <input type="text" id="playerSearch" placeholder="Search player..." oninput="searchPlayer()">
      </div>
      <div class="filter-options">
        <label><input type="checkbox" id="hideInLobby" checked onchange="updatePlayersList()"> Hide players in lobbies</label>
        <label><input type="checkbox" id="hideInQueue" onchange="updatePlayersList()"> Hide players in queue</label>
        <label><input type="checkbox" id="hideOffline" onchange="updatePlayersList()"> Hide offline players</label>
        <label><input type="checkbox" id="showBannedOnly" onchange="updatePlayersList()"> Show banned only</label>
        <label><input type="checkbox" id="bhvFilter1" onchange="updatePlayersList()"> 0-5000 BHV</label>
        <label><input type="checkbox" id="bhvFilter2" onchange="updatePlayersList()"> 5000-7500 BHV</label>
        <label><input type="checkbox" id="bhvFilter3" onchange="updatePlayersList()"> 7500+ BHV</label>
      </div>
      <div class="sort-options">
        <button class="sort-btn" onclick="sortPlayers('name', 'asc')">Name A-Z</button>
        <button class="sort-btn" onclick="sortPlayers('name', 'desc')">Name Z-A</button>
        <button class="sort-btn" onclick="sortPlayers('mmr', 'asc')">MMR Low-High</button>
        <button class="sort-btn" onclick="sortPlayers('mmr', 'desc')">MMR High-Low</button>
        <button class="sort-btn" onclick="sortPlayers('bhv', 'asc')">BHV Low-High</button>
        <button class="sort-btn" onclick="sortPlayers('bhv', 'desc')">BHV High-Low</button>
      </div>
      <div class="player-list" id="allPlayersList">
        <div id="playersListContent"></div>
      </div>
      <button onclick="showMainPage()">Back to Lobby</button>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="editModal">
      <div class="modal-content">
        <h3>Edit Player</h3>
        <input type="text" id="editName" placeholder="Nickname">
        <input type="number" id="editMMR" placeholder="MMR">
        <input type="number" id="editBHV" placeholder="BHV">
        <input type="text" id="editFriendId" placeholder="Friend ID">
        <textarea id="editNote" placeholder="Notes..." rows="3"></textarea>
        <div class="modal-buttons">
          <button onclick="savePlayerChanges()">Save</button>
          <button onclick="closeModal()">Cancel</button>
          <button id="banButton" class="danger" onclick="toggleBanPlayer()">Ban</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const lobbies = [
      { team1: [], team2: [] },
      { team1: [], team2: [] },
      { team1: [], team2: [] }
    ];
    let globalQueue = [];
    let allPlayers = [];
    let currentLobby = 0;
    let currentlyEditedPlayer = null;
    let currentSort = { field: 'name', direction: 'asc' };
    let bhvFilters = {
      '0-5000': false,
      '5000-7500': false,
      '7500-12000': false
    };

    function switchLobby(index) {
      currentLobby = index;
      document.querySelectorAll('.tab').forEach((el, i) => {
        el.classList.toggle('active-tab', i === index);
      });
      renderLobby();
    }

    function showAllPlayersPage() {
      document.getElementById('mainPage').style.display = 'none';
      document.getElementById('allPlayersPage').style.display = 'block';
      updatePlayersList();
    }

    function showMainPage() {
      document.getElementById('mainPage').style.display = 'block';
      document.getElementById('allPlayersPage').style.display = 'none';
      renderLobby();
    }

    function getColor(bhv) {
      if (bhv < 5000) return 'red';
      if (bhv < 7500) return 'yellow';
      return 'green';
    }

    function getPlayerStatus(player) {
      for (let i = 0; i < lobbies.length; i++) {
        if (lobbies[i].team1.some(p => p.name === player.name)) {
          return `Lobby ${i+1} Team 1`;
        }
        if (lobbies[i].team2.some(p => p.name === player.name)) {
          return `Lobby ${i+1} Team 2`;
        }
      }
      if (globalQueue.some(p => p.name === player.name)) {
        return 'In Queue';
      }
      return player.lastSeen ? `Offline (last seen: ${player.lastSeen})` : 'Offline';
    }

    function getStatusClass(status) {
      if (status === 'In Queue') return 'status-queue';
      if (status.includes('Team 1')) return 'status-team1';
      if (status.includes('Team 2')) return 'status-team2';
      if (status.includes('Lobby 1')) return 'status-lobby1';
      if (status.includes('Lobby 2')) return 'status-lobby2';
      if (status.includes('Lobby 3')) return 'status-lobby3';
      return '';
    }

    function showPlayerSuggestions() {
      const input = document.getElementById('name').value.toLowerCase();
      if (!input) {
        document.getElementById('playerSuggestions').style.display = 'none';
        return;
      }

      const suggestions = allPlayers
        .filter(p => !p.banned && p.name.toLowerCase().includes(input) && !globalQueue.some(q => q.name === p.name) && !lobbies.some(l => l.team1.concat(l.team2).some(t => t.name === p.name)))
        .slice(0, 5);

      const suggestionsDiv = document.getElementById('playerSuggestions');
      suggestionsDiv.innerHTML = '';
      
      if (suggestions.length === 0) {
        suggestionsDiv.style.display = 'none';
        return;
      }

      suggestions.forEach(player => {
        const div = document.createElement('div');
        div.className = 'suggestion-item';
        div.textContent = `${player.name} (MMR: ${player.mmr}, BHV: ${player.bhv})`;
        div.onclick = () => {
          document.getElementById('name').value = player.name;
          document.getElementById('mmr').value = player.mmr;
          document.getElementById('bhv').value = player.bhv;
          document.getElementById('friendId').value = player.friendId || '';
          suggestionsDiv.style.display = 'none';
        };
        suggestionsDiv.appendChild(div);
      });

      suggestionsDiv.style.display = 'block';
    }

    function addToQueue() {
      const name = document.getElementById('name').value;
      const mmr = parseInt(document.getElementById('mmr').value);
      const bhv = parseInt(document.getElementById('bhv').value);
      const friendId = document.getElementById('friendId').value;
      
      if (!name || isNaN(mmr) || isNaN(bhv)) return;

      // Check if player is banned
      const bannedPlayer = allPlayers.find(p => (p.friendId && p.friendId === friendId && p.banned) || 
                     (p.name === name && p.banned));
      if (bannedPlayer) {
        alert("This player is banned and cannot be added");
        return;
      }

      const alreadyInGame = lobbies.some(lobby =>
        lobby.team1.concat(lobby.team2).some(p => p.name === name)
      );
      if (alreadyInGame) {
        alert("Player is already in one of the lobbies");
        return;
      }

      const alreadyInQueue = globalQueue.some(p => p.name === name);
      if (alreadyInQueue) {
        alert("Player is already in queue");
        return;
      }

      const player = { name, mmr, bhv, friendId, lastSeen: new Date().toLocaleDateString() };
      globalQueue.unshift(player);
      
      // Add to all players list if not exists
      const existingPlayer = allPlayers.find(p => p.name === name || (friendId && p.friendId === friendId));
      if (!existingPlayer) {
        allPlayers.push({...player});
      } else {
        // Update existing player data
        existingPlayer.mmr = mmr;
        existingPlayer.bhv = bhv;
        existingPlayer.friendId = friendId;
        existingPlayer.lastSeen = new Date().toLocaleDateString();
      }

      renderLobby();
      saveToLocalStorage();
      
      // Clear input fields
      document.getElementById('name').value = '';
      document.getElementById('mmr').value = '';
      document.getElementById('bhv').value = '';
      document.getElementById('friendId').value = '';
      document.getElementById('playerSuggestions').style.display = 'none';
    }

    function moveAllToLobby() {
      const lobby = lobbies[currentLobby];
      const sorted = [...globalQueue].sort((a, b) => a.mmr - b.mmr);
      globalQueue = [];
      lobby.team1 = [];
      lobby.team2 = [];
      
      // Distribute players with MMR priority
      sorted.forEach((p, i) => {
        if (i % 2 === 0) {
          lobby.team1.push(p);
        } else {
          lobby.team2.push(p);
        }
      });
      
      renderLobby();
      saveToLocalStorage();
    }

    function allowDrop(ev) {
      ev.preventDefault();
      ev.target.classList.add('highlight');
    }

    function clearHighlight(ev) {
      ev.target.classList.remove('highlight');
    }

    function drag(ev, source, index) {
      ev.dataTransfer.setData("text", JSON.stringify({ source, index }));
    }

    function drop(ev, target) {
      ev.preventDefault();
      const data = JSON.parse(ev.dataTransfer.getData("text"));
      
      let player;
      if (data.source === 'queue') {
        player = globalQueue.splice(data.index, 1)[0];
      } else {
        player = lobbies[currentLobby][data.source].splice(data.index, 1)[0];
      }
      
      // Check if player is banned
      if (player.banned) {
        alert("Banned players cannot be added to teams or queue");
        globalQueue.push(player); // Return to queue
        renderLobby();
        ev.target.classList.remove('highlight');
        return;
      }
      
      if (target === 'queue') {
        globalQueue.push(player);
      } else {
        lobbies[currentLobby][target].push(player);
      }
      
      renderLobby();
      saveToLocalStorage();
      ev.target.classList.remove('highlight');
    }

    function renderLobby() {
      function createPlayerElement(p, source, index, isQueue = false) {
        const el = document.createElement('div');
        el.className = `player ${p.banned ? 'banned' : getColor(p.bhv)}`;
        el.draggable = !p.banned;
        if (!p.banned) {
          el.ondragstart = (e) => drag(e, source, index);
        }
        el.ondblclick = () => openEditModal(p, { source, index, isQueue });
        
        const actions = isQueue ? `
          <div class="queue-player-actions">
            <button onclick=\"addToTeam('${source}', ${index}, 'team1')\" ${p.banned ? 'disabled' : ''}>Team 1</button>
            <button onclick=\"addToTeam('${source}', ${index}, 'team2')\" ${p.banned ? 'disabled' : ''}>Team 2</button>
            <button onclick=\"kickPlayer('${source}', ${index}, ${isQueue})\">Kick</button>
          </div>
        ` : `
          <div>
            <button onclick=\"kickPlayer('${source}', ${index}, ${isQueue})\">Kick</button>
            <button onclick=\"moveToQueue('${source}', ${index})\" ${p.banned ? 'disabled' : ''}>To Queue</button>
          </div>
        `;
        
        el.innerHTML = `
          <div>${p.name} | MMR: ${p.mmr} | BHV: ${p.bhv} ${p.banned ? '| BANNED' : ''}</div>
          ${actions}
        `;
        return el;
      }
      
      const lobby = lobbies[currentLobby];

      // Render teams
      ["team1", "team2"].forEach(team => {
        const div = document.getElementById(`${team}Players`);
        div.innerHTML = '';
        lobby[team].forEach((p, i) => {
          const el = createPlayerElement(p, team, i);
          div.appendChild(el);
        });

        // Update team count
        document.getElementById(`${team}Count`).textContent = lobby[team].length;

        const sum = arr => arr.reduce((sum, x) => sum + x, 0);
        const activePlayers = lobby[team].filter(p => !p.banned);
        const sumMMR = sum(activePlayers.map(p => p.mmr));
        const sumBHV = sum(activePlayers.map(p => p.bhv));
        const avgMMR = (sumMMR / (activePlayers.length || 1)).toFixed(1);
        const avgBHV = (sumBHV / (activePlayers.length || 1)).toFixed(1);
        
        const statsDiv = document.getElementById(`${team}Stats`);
        statsDiv.innerHTML = `
          <div class="team-stats">
            <span class="team-stat">Avg MMR: ${avgMMR}</span>
            <span class="team-stat">Avg BHV: ${avgBHV}</span>
            <span class="team-stat">Sum MMR: ${sumMMR}</span>
            <span class="team-stat">Sum BHV: ${sumBHV}</span>
          </div>
        `;
      });

      // Render queue
      const queueDiv = document.getElementById('waitingList');
      queueDiv.innerHTML = '';
      globalQueue.forEach((p, i) => {
        const el = createPlayerElement(p, 'queue', i, true);
        queueDiv.appendChild(el);
      });

      // Update queue count
      document.getElementById('queueCount').textContent = globalQueue.length;
    }

    function addToTeam(source, index, targetTeam) {
      if (source !== 'queue') return;
      
      const player = globalQueue.splice(index, 1)[0];
      
      // Check if player is banned
      if (player.banned) {
        alert("Banned players cannot be added to teams");
        globalQueue.splice(index, 0, player); // Return to original position
        renderLobby();
        return;
      }
      
      lobbies[currentLobby][targetTeam].push(player);
      renderLobby();
      saveToLocalStorage();
    }

    function balanceTeams() {
      const lobby = lobbies[currentLobby];
      
      // Combine all players from both teams (excluding banned)
      let players = [...lobby.team1, ...lobby.team2].filter(p => !p.banned);
      
      // Reset teams
      lobby.team1 = [];
      lobby.team2 = [];
      
      // Sort by BHV first (ascending) then by MMR (descending)
      players.sort((a, b) => {
        if (a.bhv !== b.bhv) return a.bhv - b.bhv;
        return b.mmr - a.mmr;
      });
      
      // Try multiple balancing attempts to find the best distribution
      let bestDiff = Infinity;
      let bestTeam1 = [];
      let bestTeam2 = [];
      
      // Several attempts to find optimal balance
      for (let attempt = 0; attempt < 10; attempt++) {
        // Shuffle players slightly for different attempts
        if (attempt > 0) {
          players = shuffleArray(players);
        }
        
        const team1 = [];
        const team2 = [];
        let team1BHV = 0, team2BHV = 0;
        let team1MMR = 0, team2MMR = 0;
        
        // Distribute players
        for (const player of players) {
          // Calculate potential new totals
          const newTeam1BHV = team1BHV + player.bhv;
          const newTeam2BHV = team2BHV + player.bhv;
          const newTeam1MMR = team1MMR + player.mmr;
          const newTeam2MMR = team2MMR + player.mmr;
          
          // Calculate differences for both options
          const diffIfTeam1 = Math.abs(newTeam1BHV - team2BHV) + Math.abs(newTeam1MMR - team2MMR) * 0.5;
          const diffIfTeam2 = Math.abs(team1BHV - newTeam2BHV) + Math.abs(team1MMR - newTeam2MMR) * 0.5;
          
          // Choose the option that minimizes both BHV and MMR differences
          if (diffIfTeam1 < diffIfTeam2) {
            team1.push(player);
            team1BHV = newTeam1BHV;
            team1MMR = newTeam1MMR;
          } else {
            team2.push(player);
            team2BHV = newTeam2BHV;
            team2MMR = newTeam2MMR;
          }
        }
        
        // Calculate total difference for this attempt
        const bhvDiff = Math.abs(team1BHV - team2BHV);
        const mmrDiff = Math.abs(team1MMR - team2MMR);
        const totalDiff = bhvDiff + mmrDiff * 0.5; // Give more weight to BHV
        
        // Keep this distribution if it's better
        if (totalDiff < bestDiff) {
          bestDiff = totalDiff;
          bestTeam1 = [...team1];
          bestTeam2 = [...team2];
        }
      }
      
      // Apply the best found distribution
      lobby.team1 = bestTeam1;
      lobby.team2 = bestTeam2;
      
      // Keep banned players in their original teams
      const bannedPlayersTeam1 = lobbies[currentLobby].team1.filter(p => p.banned);
      const bannedPlayersTeam2 = lobbies[currentLobby].team2.filter(p => p.banned);
      lobby.team1.push(...bannedPlayersTeam1);
      lobby.team2.push(...bannedPlayersTeam2);
      
      renderLobby();
      saveToLocalStorage();
    }

    function createBestLobby() {
      if (globalQueue.length < 10) {
        alert("Need at least 10 players in queue to create a 5v5 lobby");
        return;
      }

      // Get top 10 players by MMR
      const candidates = [...globalQueue]
        .filter(p => !p.banned)
        .sort((a, b) => b.mmr - a.mmr)
        .slice(0, Math.min(20, globalQueue.length)); // Take top 20 MMR players

      if (candidates.length < 10) {
        alert("Not enough unbanned players in queue to create a 5v5 lobby");
        return;
      }

      // Find the most balanced 10 players group
      let bestGroup = [];
      let bestDiff = Infinity;

      // Try multiple random combinations to find the most balanced
      for (let i = 0; i < 100; i++) {
        const shuffled = shuffleArray([...candidates]);
        const group = shuffled.slice(0, 10);
        
        // Calculate MMR and BHV variance
        const mmrs = group.map(p => p.mmr);
        const bhvs = group.map(p => p.bhv);
        
        const mmrDiff = Math.max(...mmrs) - Math.min(...mmrs);
        const bhvDiff = Math.max(...bhvs) - Math.min(...bhvs);
        const totalDiff = mmrDiff * 0.5 + bhvDiff; // More weight to BHV
        
        if (totalDiff < bestDiff) {
          bestDiff = totalDiff;
          bestGroup = group;
        }
      }

      // Remove selected players from queue
      globalQueue = globalQueue.filter(p => !bestGroup.some(g => g.name === p.name));

      // Add to current lobby
      const lobby = lobbies[currentLobby];
      lobby.team1 = [];
      lobby.team2 = [];

      // Distribute players to teams
      bestGroup.sort((a, b) => b.mmr - a.mmr); // Sort by MMR descending
      bestGroup.forEach((p, i) => {
        if (i % 2 === 0) {
          lobby.team1.push(p);
        } else {
          lobby.team2.push(p);
        }
      });

      renderLobby();
      saveToLocalStorage();
    }

    function shuffleArray(array) {
      const newArray = [...array];
      for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
      }
      return newArray;
    }

    function kickPlayer(source, index, isQueue = false) {
      if (isQueue) {
        globalQueue.splice(index, 1);
      } else {
        lobbies[currentLobby][source].splice(index, 1);
      }
      renderLobby();
      saveToLocalStorage();
    }

    function moveToQueue(source, index) {
      const player = lobbies[currentLobby][source].splice(index, 1)[0];
      if (!player.banned) {
        globalQueue.push(player);
      }
      renderLobby();
      saveToLocalStorage();
    }

    function clearQueue() {
      if (confirm("Clear the queue? All players will be removed.")) {
        globalQueue = [];
        renderLobby();
        saveToLocalStorage();
      }
    }

    function searchPlayer() {
      updatePlayersList(document.getElementById("playerSearch").value.toLowerCase());
    }

    function sortPlayers(field, direction) {
      currentSort = { field, direction };
      updatePlayersList();
      
      // Update active sort button
      document.querySelectorAll('.sort-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.textContent.includes(field === 'name' ? 'Name' : 
                                     field === 'mmr' ? 'MMR' : 
                                     field === 'bhv' ? 'BHV' : '') &&
            btn.textContent.includes(direction === 'asc' ? 'A-Z' : 
                                    direction === 'asc' ? 'Low-High' : 
                                    direction === 'desc' ? 'Z-A' : 'High-Low')) {
          btn.classList.add('active');
        }
      });
    }

    function updatePlayersList(filter = "") {
      const listElement = document.getElementById("playersListContent");
      listElement.innerHTML = "";

      // Apply filters
      const hideInLobby = document.getElementById("hideInLobby").checked;
      const hideInQueue = document.getElementById("hideInQueue").checked;
      const hideOffline = document.getElementById("hideOffline").checked;
      const showBannedOnly = document.getElementById("showBannedOnly").checked;
      const bhvFilter1 = document.getElementById("bhvFilter1").checked;
      const bhvFilter2 = document.getElementById("bhvFilter2").checked;
      const bhvFilter3 = document.getElementById("bhvFilter3").checked;
      
      let filteredPlayers = allPlayers.filter(player => {
        const inLobby = lobbies.some(l => l.team1.concat(l.team2).some(p => p.name === player.name));
        const inQueue = globalQueue.some(p => p.name === player.name);
        const isOnline = inLobby || inQueue;
        
        // Apply BHV filters if any are active
        if (bhvFilter1 || bhvFilter2 || bhvFilter3) {
          const bhv = player.bhv;
          const matchesFilter = 
            (bhvFilter1 && bhv >= 0 && bhv < 5000) ||
            (bhvFilter2 && bhv >= 5000 && bhv < 7500) ||
            (bhvFilter3 && bhv >= 7500);
          
          if (!matchesFilter) return false;
        }
        
        if (showBannedOnly) return player.banned;
        if (hideInLobby && inLobby) return false;
        if (hideInQueue && inQueue) return false;
        if (hideOffline && !isOnline) return false;
        if (filter && !player.name.toLowerCase().includes(filter)) return false;
        return true;
      });

      // Apply sorting
      filteredPlayers.sort((a, b) => {
        let valA, valB;
        
        if (currentSort.field === 'lastSeen') {
          valA = new Date(a.lastSeen || 0);
          valB = new Date(b.lastSeen || 0);
        } else {
          valA = a[currentSort.field];
          valB = b[currentSort.field];
        }
        
        if (typeof valA === 'string') valA = valA.toLowerCase();
        if (typeof valB === 'string') valB = valB.toLowerCase();
        
        if (valA < valB) return currentSort.direction === 'asc' ? -1 : 1;
        if (valA > valB) return currentSort.direction === 'asc' ? 1 : -1;
        return 0;
      });

      filteredPlayers.forEach((player) => {
        const status = getPlayerStatus(player);
        const statusClass = getStatusClass(status);
        
        const playerElement = document.createElement("div");
        playerElement.className = `player-list-item ${player.banned ? 'banned' : getColor(player.bhv)}`;
        playerElement.innerHTML = `
          <div>
            <strong>${player.name}</strong> 
            <span class="player-status ${statusClass}">${status}</span>
          </div>
          <div>MMR: ${player.mmr} | BHV: ${player.bhv}</div>
          <div class="player-actions">
            <button onclick="addPlayerToQueueFromList('${player.name}')" ${player.banned ? 'disabled' : ''}>Add to Queue</button>
            <button onclick="openEditModal(${JSON.stringify(player)}, findPlayerLocation(${JSON.stringify(player)}))">Edit</button>
          </div>
        `;
        playerElement.ondblclick = () => {
          // Switch to the lobby where the player is located if in lobby
          for (let i = 0; i < lobbies.length; i++) {
            if (lobbies[i].team1.some(p => p.name === player.name) || lobbies[i].team2.some(p => p.name === player.name)) {
              if (i !== currentLobby) {
                switchLobby(i);
                showMainPage();
              }
              break;
            }
          }
          openEditModal(player, findPlayerLocation(player));
        };
        listElement.appendChild(playerElement);
      });
    }

    function addPlayerToQueueFromList(playerName) {
      const player = allPlayers.find(p => p.name === playerName);
      if (!player) return;

      if (player.banned) {
        alert("Banned players cannot be added to queue");
        return;
      }

      const alreadyInGame = lobbies.some(lobby =>
        lobby.team1.concat(lobby.team2).some(p => p.name === player.name)
      );
      if (alreadyInGame) {
        alert("Player is already in one of the lobbies");
        return;
      }

      const alreadyInQueue = globalQueue.some(p => p.name === player.name);
      if (alreadyInQueue) {
        alert("Player is already in queue");
        return;
      }

      globalQueue.unshift({...player});
      renderLobby();
      updatePlayersList();
      saveToLocalStorage();
    }

    function findPlayerLocation(player) {
      // Check if player is in queue
      const queueIndex = globalQueue.findIndex(p => p.name === player.name);
      if (queueIndex !== -1) {
        return { source: 'queue', index: queueIndex, isQueue: true };
      }
      
      // Check if player is in any lobby
      for (let i = 0; i < lobbies.length; i++) {
        const lobby = lobbies[i];
        for (const [source, players] of Object.entries(lobby)) {
          const index = players.findIndex(p => p.name === player.name);
          if (index !== -1) return { source, index, lobbyIndex: i };
        }
      }
      return null;
    }

    function openEditModal(player, location) {
      currentlyEditedPlayer = { player, location };
      document.getElementById("editName").value = player.name;
      document.getElementById("editMMR").value = player.mmr;
      document.getElementById("editBHV").value = player.bhv;
      document.getElementById("editFriendId").value = player.friendId || '';
      document.getElementById("editNote").value = player.note || "";
      
      const banButton = document.getElementById("banButton");
      if (player.banned) {
        banButton.textContent = "Unban";
        banButton.className = "success";
      } else {
        banButton.textContent = "Ban";
        banButton.className = "danger";
      }
      
      document.getElementById("editModal").style.display = "flex";
    }

    function toggleBanPlayer() {
      const { player } = currentlyEditedPlayer;
      player.banned = !player.banned;
      player.lastSeen = new Date().toLocaleDateString();
      
      // Update in allPlayers list
      const allPlayerIndex = allPlayers.findIndex(p => 
        p.name === player.name || (player.friendId && p.friendId === player.friendId)
      );
      if (allPlayerIndex !== -1) {
        allPlayers[allPlayerIndex].banned = player.banned;
        allPlayers[allPlayerIndex].lastSeen = player.lastSeen;
      }
      
      // Remove from queues/lobbies if banned
      if (player.banned) {
        // Remove from global queue
        globalQueue = globalQueue.filter(p => p.name !== player.name);
        
        // Remove from all lobbies
        lobbies.forEach(lobby => {
          lobby.team1 = lobby.team1.filter(p => p.name !== player.name);
          lobby.team2 = lobby.team2.filter(p => p.name !== player.name);
        });
      }
      
      saveToLocalStorage();
      renderLobby();
      updatePlayersList();
      closeModal();
    }

    function closeModal() {
      document.getElementById("editModal").style.display = "none";
    }

    function savePlayerChanges() {
      const name = document.getElementById("editName").value;
      const mmr = parseInt(document.getElementById("editMMR").value);
      const bhv = parseInt(document.getElementById("editBHV").value);
      const friendId = document.getElementById("editFriendId").value;
      const note = document.getElementById("editNote").value;

      if (!name || isNaN(mmr) || isNaN(bhv)) {
        alert("Please fill all fields correctly!");
        return;
      }

      const { player, location } = currentlyEditedPlayer;
      if (!location) return;

      // Check if friendId is already used by another player
      if (friendId && friendId !== player.friendId) {
        const existingPlayer = allPlayers.find(p => p.friendId === friendId && p.name !== player.name);
        if (existingPlayer) {
          alert("This Friend ID is already used by another player");
          return;
        }
      }

      // Update player data in all locations
      player.name = name;
      player.mmr = mmr;
      player.bhv = bhv;
      player.friendId = friendId;
      player.note = note;
      player.lastSeen = new Date().toLocaleDateString();

      // Update in allPlayers list
      const allPlayerIndex = allPlayers.findIndex(p => 
        p.name === player.name || (player.friendId && p.friendId === player.friendId)
      );
      if (allPlayerIndex !== -1) {
        allPlayers[allPlayerIndex] = {...player};
      } else {
        allPlayers.push({...player});
      }

      closeModal();
      renderLobby();
      updatePlayersList();
      saveToLocalStorage();
    }

    function clearCurrentLobby() {
      if (confirm("Clear the current lobby? All players will be moved to queue.")) {
        const lobby = lobbies[currentLobby];
        // Move only unbanned players to queue
        globalQueue.push(...lobby.team1.filter(p => !p.banned), ...lobby.team2.filter(p => !p.banned));
        lobby.team1 = [];
        lobby.team2 = [];
        renderLobby();
        saveToLocalStorage();
      }
    }

    function saveToLocalStorage() {
      localStorage.setItem('dotaBalancerData', JSON.stringify({
        lobbies,
        globalQueue,
        allPlayers
      }));
    }

    function loadFromLocalStorage() {
      const savedData = localStorage.getItem('dotaBalancerData');
      if (savedData) {
        const parsedData = JSON.parse(savedData);
        if (parsedData.lobbies) {
          parsedData.lobbies.forEach((lobby, index) => {
            lobbies[index] = lobby;
          });
        }
        if (parsedData.globalQueue) {
          globalQueue = parsedData.globalQueue;
        }
        if (parsedData.allPlayers) {
          allPlayers = parsedData.allPlayers;
        } else {
          // Migrate from old version
          allPlayers = [...globalQueue];
          lobbies.forEach(lobby => {
            allPlayers.push(...lobby.team1, ...lobby.team2);
          });
          // Remove duplicates
          allPlayers = allPlayers.filter((player, index, self) =>
            index === self.findIndex(p => p.name === player.name)
          );
        }
        renderLobby();
      }
    }

    window.onload = () => {
      loadFromLocalStorage();
      renderLobby();
    };
  </script>
</body>
</html>
