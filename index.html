<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dota 2 Team Balancer</title>
  <style>
    #backgroundSelect {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 9999;
      background: rgba(0,0,0,0.5);
      color: white;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      font-family: Arial, sans-serif;
    }
    body {
      margin: 0;
      font-family: 'Arial', sans-serif;
      overflow-x: hidden;
      color: white;
    }
    .background {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: url('dota2-background.gif') center/cover no-repeat;
      filter: blur(3px) brightness(0.7);
      z-index: 0;
    }
    .overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 1;
    }
    .container {
      position: relative;
      z-index: 2;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
    }
    .form-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
      align-items: center;
    }
    input {
      padding: 10px;
      font-size: 1rem;
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      border-radius: 4px;
    }
    input::placeholder {
      color: rgba(255,255,255,0.7);
    }
    button {
      padding: 10px 15px;
      cursor: pointer;
      background: #4a5568;
      color: white;
      border: none;
      border-radius: 4px;
      font-weight: bold;
      transition: all 0.2s;
    }
    button:hover {
      background: #2d3748;
      transform: translateY(-1px);
    }
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .tab {
      padding: 10px 15px;
      background: rgba(255,255,255,0.1);
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
      font-weight: bold;
    }
    .tab:hover {
      background: rgba(255,255,255,0.2);
    }
    .active-tab {
      background: #4299e1;
      font-weight: bold;
    }
    .team {
      margin: 20px 0;
      padding: 15px;
      background: rgba(0,0,0,0.4);
      border-radius: 10px;
      min-height: 150px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .player {
      padding: 8px 12px;
      margin: 5px 0;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.2s;
    }
    .player:hover {
      transform: translateX(3px);
    }
    .red { background-color: rgba(239, 68, 68, 0.8); }
    .yellow { background-color: rgba(234, 179, 8, 0.8); color: #000; }
    .green { background-color: rgba(34, 197, 94, 0.8); }
    .banned { 
      background-color: rgba(0,0,0,0.8);
      color: white;
      font-weight: bold;
      border: 1px solid #f00;
    }
    .queue-container {
      margin-top: 30px;
      background: rgba(0,0,0,0.4);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .queue-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .queue-content {
      max-height: 300px;
      overflow-y: auto;
    }
    .search-container {
      margin: 15px 0;
    }
    #playerSearch {
      width: 250px;
      padding: 10px;
      background: rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.2);
    }
    .player-list {
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      max-height: 500px;
      overflow-y: auto;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .player-list-item {
      padding: 10px;
      margin: 5px 0;
      cursor: pointer;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255,255,255,0.05);
      transition: all 0.2s;
    }
    .player-list-item:hover {
      background: rgba(255, 255, 255, 0.15);
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 100;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background: #1a202c;
      padding: 25px;
      border-radius: 10px;
      width: 350px;
      max-width: 90%;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
    .modal-content input, .modal-content textarea {
      width: 100%;
      padding: 10px;
      margin: 8px 0;
      background: rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.2);
      color: white;
      border-radius: 4px;
    }
    .modal-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
      gap: 10px;
    }
    .modal-buttons button {
      padding: 10px 15px;
      flex: 1;
    }
    button.danger {
      background-color: #e53e3e;
      color: white;
    }
    button.danger:hover {
      background-color: #c53030;
    }
    button.success {
      background-color: #48bb78;
      color: white;
    }
    button.success:hover {
      background-color: #38a169;
    }
    .team.highlight {
      background: rgba(255, 255, 255, 0.1);
      transition: background 0.2s;
    }
    .player-status {
      font-size: 0.9em;
      margin-left: 8px;
      color: white;
      opacity: 0.9;
    }
    .status-queue { color: #a0aec0; }
    .status-team1 { color: #fc8181; }
    .status-team2 { color: #68d391; }
    .status-lobby1 { color: #63b3ed; }
    .status-lobby2 { color: #f6ad55; }
    .status-lobby3 { color: #b794f4; }
    .filter-options {
      margin: 15px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
    }
    .filter-options label {
      display: flex;
      align-items: center;
      gap: 5px;
      cursor: pointer;
      font-size: 0.95em;
    }
    .queue-player-actions {
      display: flex;
      gap: 8px;
    }
    .team-count {
      font-size: 0.9em;
      opacity: 0.9;
      margin-left: 10px;
    }
    .suggestions {
      position: absolute;
      background: #2d3748;
      border: 1px solid #4a5568;
      max-height: 200px;
      overflow-y: auto;
      z-index: 10;
      width: calc(100% - 16px);
      max-width: 300px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    .suggestion-item {
      padding: 10px;
      cursor: pointer;
      transition: all 0.1s;
    }
    .suggestion-item:hover {
      background: #4a5568;
    }
    .team-stats {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
      font-size: 0.95em;
      flex-wrap: wrap;
      gap: 10px;
    }
    .team-stat {
      background: rgba(0,0,0,0.3);
      padding: 5px 10px;
      border-radius: 4px;
    }
    .player-actions {
      display: flex;
      gap: 8px;
    }
    .sort-options {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0;
    }
    .sort-btn {
      padding: 6px 12px;
      font-size: 0.85em;
      background: rgba(255,255,255,0.1);
    }
    .sort-btn.active {
      background: #4299e1;
    }
    h1, h2, h3 {
      color: white;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    h1 {
      margin-top: 0;
      font-size: 2.2em;
    }
    h2 {
      font-size: 1.8em;
    }
    h3 {
      font-size: 1.4em;
      display: flex;
      align-items: center;
    }
    .teams {
      display: flex;
      gap: 20px;
    }
    @media (max-width: 768px) {
      .form-group {
        flex-direction: column;
        align-items: stretch;
      }
      .teams {
        flex-direction: column;
      }
      .team-stats {
        flex-direction: column;
      }
      .player-actions {
        flex-direction: column;
      }
      input {
        width: 100%;
      }
      .modal-buttons {
        flex-direction: column;
      }
    }
  </style>
</head>
<div style="position: fixed; bottom: 70px; right: 20px; z-index: 9999;">
  <button onclick="downloadPlayers()">üíæ Download</button>
  <input type="file" id="loadFile" accept=".json" style="display: none;" onchange="loadPlayers(event)">
  <button onclick="document.getElementById('loadFile').click()">üìÇ Load</button>
</div>
<body>
  <div id="playerList" style="position: relative; z-index: 2; margin-top: 100px; color: white;"></div>
  <div id="dynamicBackground" class="background"></div>
  <div class="overlay"></div>
  <div class="container">
    <div class="tabs">
      <div class="tab active-tab" onclick="switchLobby(0)">Lobby 1</div>
      <div class="tab" onclick="switchLobby(1)">Lobby 2</div>
      <div class="tab" onclick="switchLobby(2)">Lobby 3</div>
      <div class="tab" onclick="showAllPlayersPage()">All Players</div>
      <button class="tab" onclick="openSettingsModal()" style="margin-left: auto;">‚öôÔ∏è Settings</button>
    </div>

    <div id="mainPage">
      <h1 id="mainTitle">Dota 2 Team Balancer</h1>
      <div id="playerList" style="position: relative; z-index: 2; margin-top: 100px; color: white;"></div>
      <div class="form-group">
        <div style="position: relative;">
          <input type="text" id="name" placeholder="Nickname" oninput="showPlayerSuggestions()">
          <div class="suggestions" id="playerSuggestions" style="display: none;"></div>
        </div>
        <input type="number" id="mmr" placeholder="Rating (MMR)">
        <input type="number" id="bhv" placeholder="BHV (0-12000)">
        <input type="text" id="friendId" placeholder="Friend ID">
        <button onclick="addToQueue()" id="addToQueueBtn">Add to Queue</button>
        <button onclick="moveAllToLobby()" id="moveAllBtn">Move All to Lobby</button>
        <button onclick="clearCurrentLobby()" class="danger" id="clearLobbyBtn">Clear Current Lobby</button>
      </div>

      <div class="teams">
        <div class="team" id="team1" ondragover="allowDrop(event)" ondrop="drop(event, 'team1')" ondragleave="clearHighlight(event)">
          <h3 id="team1Title">Team 1 <span class="team-count">(<span id="team1Count">0</span>/5)</span></h3>
          <div id="team1Players"></div>
          <div class="team-stats" id="team1Stats"></div>
        </div>
        <div class="team" id="team2" ondragover="allowDrop(event)" ondrop="drop(event, 'team2')" ondragleave="clearHighlight(event)">
          <h3 id="team2Title">Team 2 <span class="team-count">(<span id="team2Count">0</span>/5)</span></h3>
          <div id="team2Players"></div>
          <div class="team-stats" id="team2Stats"></div>
        </div>
      </div>

      <div class="form-group">
        <button onclick="balanceTeams()" id="balanceBtn">Balance Teams</button>
        <button onclick="suggestBetterSwap()">üîÅ –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∑–∞–º–µ–Ω—É</button>
      </div>

      <div class="queue-container">
        <div class="queue-header">
          <h3 id="queueTitle">Global Queue <span class="team-count">(<span id="queueCount">0</span>)</span></h3>
          <div>
            <button onclick="createBestLobby()" style="margin-right: 10px;" id="createLobbyBtn">Create Best Lobby</button>
            <button onclick="clearQueue()" class="danger" id="clearQueueBtn">Clear Queue</button>
          </div>
        </div>
        <div class="queue-content" id="waitingList" ondragover="allowDrop(event)" ondrop="drop(event, 'queue')" ondragleave="clearHighlight(event)">
          <!-- Queue content will be rendered here -->
        </div>
      </div>
    </div>

    <div id="allPlayersPage" style="display: none;">
      <h1 id="allPlayersTitle">All Players</h1>
      <div class="search-container">
        <input type="text" id="playerSearch" placeholder="Search player..." oninput="searchPlayer()">
      </div>
      <div class="filter-options">
        <label><input type="checkbox" id="hideInLobby" checked onchange="updatePlayersList()"> <span id="hideInLobbyLabel">Hide players in lobbies</span></label>
        <label><input type="checkbox" id="hideInQueue" onchange="updatePlayersList()"> <span id="hideInQueueLabel">Hide players in queue</span></label>
        <label><input type="checkbox" id="hideOffline" onchange="updatePlayersList()"> <span id="hideOfflineLabel">Hide offline players</span></label>
        <label><input type="checkbox" id="showBannedOnly" onchange="updatePlayersList()"> <span id="showBannedLabel">Show banned only</span></label>
        <label><input type="checkbox" id="bhvFilter1" onchange="updatePlayersList()"> <span id="bhvFilter1Label">0-5000 BHV</span></label>
        <label><input type="checkbox" id="bhvFilter2" onchange="updatePlayersList()"> <span id="bhvFilter2Label">5000-7500 BHV</span></label>
        <label><input type="checkbox" id="bhvFilter3" onchange="updatePlayersList()"> <span id="bhvFilter3Label">7500+ BHV</span></label>
      </div>
      <div class="sort-options">
        <button class="sort-btn" onclick="sortPlayers('name', 'asc')" id="sortNameAsc">Name A-Z</button>
        <button class="sort-btn" onclick="sortPlayers('name', 'desc')" id="sortNameDesc">Name Z-A</button>
        <button class="sort-btn" onclick="sortPlayers('mmr', 'asc')" id="sortMmrAsc">MMR Low-High</button>
        <button class="sort-btn" onclick="sortPlayers('mmr', 'desc')" id="sortMmrDesc">MMR High-Low</button>
        <button class="sort-btn" onclick="sortPlayers('bhv', 'asc')" id="sortBhvAsc">BHV Low-High</button>
        <button class="sort-btn" onclick="sortPlayers('bhv', 'desc')" id="sortBhvDesc">BHV High-Low</button>
      </div>
      <div class="player-list" id="allPlayersList">
        <div id="playersListContent"></div>
      </div>
      <button onclick="showMainPage()" id="backToLobbyBtn">Back to Lobby</button>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="editModal">
      <div class="modal-content">
        <h3 id="editPlayerTitle">Edit Player</h3>
        <input type="text" id="editName" placeholder="Nickname">
        <input type="number" id="editMMR" placeholder="MMR">
        <input type="number" id="editBHV" placeholder="BHV">
        <input type="text" id="editFriendId" placeholder="Friend ID">
        <textarea id="editNote" placeholder="Notes..." rows="3"></textarea>
        <div class="modal-buttons">
          <button onclick="savePlayerChanges()" id="savePlayerBtn">Save</button>
          <button onclick="closeModal()" id="cancelEditBtn">Cancel</button>
          <button id="banButton" class="danger" onclick="toggleBanPlayer()">Ban</button>
        </div>
      </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
      <div class="modal-content">
        <h3 id="settingsTitle">Settings</h3>
        <div class="form-group">
          <label id="languageLabel">Language:</label>
          <select id="languageSelect" onchange="changeLanguage()">
            <option value="en">English</option>
            <option value="ru">–†—É—Å—Å–∫–∏–π</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button onclick="closeSettingsModal()" id="closeSettingsBtn">Close</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const lobbies = [
      { team1: [], team2: [] },
      { team1: [], team2: [] },
      { team1: [], team2: [] }
    ];
    let globalQueue = [];
    let allPlayers = [];
    let currentLobby = 0;
    let currentlyEditedPlayer = null;
    let currentSort = { field: 'name', direction: 'asc' };
    let currentLanguage = 'en';
    let bhvFilters = {
      '0-5000': false,
      '5000-7500': false,
      '7500-12000': false
    };

    // Translations
    const translations = {
      en: {
        title: "Dota 2 Team Balancer",
        nickname: "Nickname",
        rating: "Rating (MMR)",
        bhv: "BHV (0-12000)",
        friendId: "Friend ID",
        addToQueue: "Add to Queue",
        moveAllToLobby: "Move All to Lobby",
        clearLobby: "Clear Current Lobby",
        team1: "Team 1",
        team2: "Team 2",
        balanceTeams: "Balance Teams",
        globalQueue: "Global Queue",
        createLobby: "Create Best Lobby",
        clearQueue: "Clear Queue",
        allPlayers: "All Players",
        hideInLobby: "Hide players in lobbies",
        hideInQueue: "Hide players in queue",
        hideOffline: "Hide offline players",
        showBanned: "Show banned only",
        bhvFilter1: "0-5000 BHV",
        bhvFilter2: "5000-7500 BHV",
        bhvFilter3: "7500+ BHV",
        backToLobby: "Back to Lobby",
        editPlayer: "Edit Player",
        save: "Save",
        cancel: "Cancel",
        ban: "Ban",
        unban: "Unban",
        settings: "Settings",
        language: "Language:",
        close: "Close",
        sortNameAsc: "Name A-Z",
        sortNameDesc: "Name Z-A",
        sortMmrAsc: "MMR Low-High",
        sortMmrDesc: "MMR High-Low",
        sortBhvAsc: "BHV Low-High",
        sortBhvDesc: "BHV High-Low"
      },
      ru: {
        title: "–ë–∞–ª–∞–Ω—Å–∏—Ä–æ–≤—â–∏–∫ –∫–æ–º–∞–Ω–¥ Dota 2",
        nickname: "–ù–∏–∫–Ω–µ–π–º",
        rating: "–†–µ–π—Ç–∏–Ω–≥ (MMR)",
        bhv: "BHV (0-12000)",
        friendId: "Friend ID",
        addToQueue: "–î–æ–±–∞–≤–∏—Ç—å –≤ –æ—á–µ—Ä–µ–¥—å",
        moveAllToLobby: "–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤—Å–µ—Ö –≤ –ª–æ–±–±–∏",
        clearLobby: "–û—á–∏—Å—Ç–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –ª–æ–±–±–∏",
        team1: "–ö–æ–º–∞–Ω–¥–∞ 1",
        team2: "–ö–æ–º–∞–Ω–¥–∞ 2",
        balanceTeams: "–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã",
        globalQueue: "–ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—á–µ—Ä–µ–¥—å",
        createLobby: "–°–æ–∑–¥–∞—Ç—å –ª—É—á—à–µ–µ –ª–æ–±–±–∏",
        clearQueue: "–û—á–∏—Å—Ç–∏—Ç—å –æ—á–µ—Ä–µ–¥—å",
        allPlayers: "–í—Å–µ –∏–≥—Ä–æ–∫–∏",
        hideInLobby: "–°–∫—Ä—ã—Ç—å –∏–≥—Ä–æ–∫–æ–≤ –≤ –ª–æ–±–±–∏",
        hideInQueue: "–°–∫—Ä—ã—Ç—å –∏–≥—Ä–æ–∫–æ–≤ –≤ –æ—á–µ—Ä–µ–¥–∏",
        hideOffline: "–°–∫—Ä—ã—Ç—å –æ—Ñ—Ñ–ª–∞–π–Ω –∏–≥—Ä–æ–∫–æ–≤",
        showBanned: "–¢–æ–ª—å–∫–æ –∑–∞–±–∞–Ω–µ–Ω–Ω—ã–µ",
        bhvFilter1: "0-5000 BHV",
        bhvFilter2: "5000-7500 BHV",
        bhvFilter3: "7500+ BHV",
        backToLobby: "–ù–∞–∑–∞–¥ –≤ –ª–æ–±–±–∏",
        editPlayer: "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∏–≥—Ä–æ–∫–∞",
        save: "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
        cancel: "–û—Ç–º–µ–Ω–∞",
        ban: "–ó–∞–±–∞–Ω–∏—Ç—å",
        unban: "–†–∞–∑–±–∞–Ω–∏—Ç—å",
        settings: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
        language: "–Ø–∑—ã–∫:",
        close: "–ó–∞–∫—Ä—ã—Ç—å",
        sortNameAsc: "–ò–º—è –ê-–Ø",
        sortNameDesc: "–ò–º—è –Ø-–ê",
        sortMmrAsc: "MMR –ù–∏–∑-–í—ã—Å",
        sortMmrDesc: "MMR –í—ã—Å-–ù–∏–∑",
        sortBhvAsc: "BHV –ù–∏–∑-–í—ã—Å",
        sortBhvDesc: "BHV –í—ã—Å-–ù–∏–∑"
      }
    };

    function switchLobby(index) {
      currentLobby = index;
      document.querySelectorAll('.tab').forEach((el, i) => {
        el.classList.toggle('active-tab', i === index);
      });
      renderLobby();
    }

    function showAllPlayersPage() {
      document.getElementById('mainPage').style.display = 'none';
      document.getElementById('allPlayersPage').style.display = 'block';
      updatePlayersList();
    }

    function showMainPage() {
      document.getElementById('mainPage').style.display = 'block';
      document.getElementById('allPlayersPage').style.display = 'none';
      renderLobby();
    }

    function getColor(bhv) {
      if (bhv < 5000) return 'red';
      if (bhv < 7500) return 'yellow';
      return 'green';
    }

    function getPlayerStatus(player) {
      for (let i = 0; i < lobbies.length; i++) {
        if (lobbies[i].team1.some(p => p.name === player.name)) {
          return `Lobby ${i+1} Team 1`;
        }
        if (lobbies[i].team2.some(p => p.name === player.name)) {
          return `Lobby ${i+1} Team 2`;
        }
      }
      if (globalQueue.some(p => p.name === player.name)) {
        return 'In Queue';
      }
      return player.lastSeen ? `Offline (last seen: ${player.lastSeen})` : 'Offline';
    }

    function getStatusClass(status) {
      if (status === 'In Queue') return 'status-queue';
      if (status.includes('Team 1')) return 'status-team1';
      if (status.includes('Team 2')) return 'status-team2';
      if (status.includes('Lobby 1')) return 'status-lobby1';
      if (status.includes('Lobby 2')) return 'status-lobby2';
      if (status.includes('Lobby 3')) return 'status-lobby3';
      return '';
    }

    function showPlayerSuggestions() {
      const input = document.getElementById('name').value.toLowerCase();
      if (!input) {
        document.getElementById('playerSuggestions').style.display = 'none';
        return;
      }

      const suggestions = allPlayers
        .filter(p => !p.banned && p.name.toLowerCase().includes(input) && !globalQueue.some(q => q.name === p.name) && !lobbies.some(l => l.team1.concat(l.team2).some(t => t.name === p.name)))
        .slice(0, 5);

      const suggestionsDiv = document.getElementById('playerSuggestions');
      suggestionsDiv.innerHTML = '';
      
      if (suggestions.length === 0) {
        suggestionsDiv.style.display = 'none';
        return;
      }

      suggestions.forEach(player => {
        const div = document.createElement('div');
        div.className = 'suggestion-item';
        div.textContent = `${player.name} (MMR: ${player.mmr}, BHV: ${player.bhv})`;
        div.onclick = () => {
          document.getElementById('name').value = player.name;
          document.getElementById('mmr').value = player.mmr;
          document.getElementById('bhv').value = player.bhv;
          document.getElementById('friendId').value = player.friendId || '';
          suggestionsDiv.style.display = 'none';
        };
        suggestionsDiv.appendChild(div);
      });

      suggestionsDiv.style.display = 'block';
    }

    function addToQueue() {
      const name = document.getElementById('name').value;
      const mmr = parseInt(document.getElementById('mmr').value);
      const bhv = parseInt(document.getElementById('bhv').value);
      const friendId = document.getElementById('friendId').value;
      
      if (!name || isNaN(mmr) || isNaN(bhv)) return;

      // Check if player is banned
      const bannedPlayer = allPlayers.find(p => (p.friendId && p.friendId === friendId && p.banned) || 
                     (p.name === name && p.banned));
      if (bannedPlayer) {
        alert(currentLanguage === 'en' ? "This player is banned and cannot be added" : "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –∑–∞–±–∞–Ω–µ–Ω –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω");
        return;
      }

      const alreadyInGame = lobbies.some(lobby =>
        lobby.team1.concat(lobby.team2).some(p => p.name === name)
      );
      if (alreadyInGame) {
        alert(currentLanguage === 'en' ? "Player is already in one of the lobbies" : "–ò–≥—Ä–æ–∫ —É–∂–µ –≤ –æ–¥–Ω–æ–º –∏–∑ –ª–æ–±–±–∏");
        return;
      }

      const alreadyInQueue = globalQueue.some(p => p.name === name);
      if (alreadyInQueue) {
        alert(currentLanguage === 'en' ? "Player is already in queue" : "–ò–≥—Ä–æ–∫ —É–∂–µ –≤ –æ—á–µ—Ä–µ–¥–∏");
        return;
      }

      const player = { name, mmr, bhv, friendId, lastSeen: new Date().toLocaleDateString() };
      globalQueue.unshift(player);
      
      // Add to all players list if not exists
      const existingPlayer = allPlayers.find(p => p.name === name || (friendId && p.friendId === friendId));
      if (!existingPlayer) {
        allPlayers.push({...player});
      } else {
        // Update existing player data
        existingPlayer.mmr = mmr;
        existingPlayer.bhv = bhv;
        existingPlayer.friendId = friendId;
        existingPlayer.lastSeen = new Date().toLocaleDateString();
      }

      renderLobby();
      saveToLocalStorage();
      
      // Clear input fields
      document.getElementById('name').value = '';
      document.getElementById('mmr').value = '';
      document.getElementById('bhv').value = '';
      document.getElementById('friendId').value = '';
      document.getElementById('playerSuggestions').style.display = 'none';
    }

    function moveAllToLobby() {
      const lobby = lobbies[currentLobby];
      const sorted = [...globalQueue].sort((a, b) => a.mmr - b.mmr);
      globalQueue = [];
      lobby.team1 = [];
      lobby.team2 = [];
      
      // Distribute players with MMR priority
      sorted.forEach((p, i) => {
        if (i % 2 === 0) {
          lobby.team1.push(p);
        } else {
          lobby.team2.push(p);
        }
      });
      
      renderLobby();
      saveToLocalStorage();
    }

    function allowDrop(ev) {
      ev.preventDefault();
      ev.target.classList.add('highlight');
    }

    function clearHighlight(ev) {
      ev.target.classList.remove('highlight');
    }

    function drag(ev, source, index) {
      ev.dataTransfer.setData("text", JSON.stringify({ source, index }));
    }

    function drop(ev, target) {
      ev.preventDefault();
      const data = JSON.parse(ev.dataTransfer.getData("text"));
      
      let player;
      if (data.source === 'queue') {
        player = globalQueue.splice(data.index, 1)[0];
      } else {
        player = lobbies[currentLobby][data.source].splice(data.index, 1)[0];
      }
      
      // Check if player is banned
      if (player.banned) {
        alert(currentLanguage === 'en' ? "Banned players cannot be added to teams or queue" : "–ó–∞–±–∞–Ω–µ–Ω–Ω—ã–µ –∏–≥—Ä–æ–∫–∏ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –∫–æ–º–∞–Ω–¥—ã –∏–ª–∏ –æ—á–µ—Ä–µ–¥—å");
        globalQueue.push(player); // Return to queue
        renderLobby();
        ev.target.classList.remove('highlight');
        return;
      }
      
      if (target === 'queue') {
        globalQueue.push(player);
      } else {
        lobbies[currentLobby][target].push(player);
      }
      
      renderLobby();
      saveToLocalStorage();
      ev.target.classList.remove('highlight');
    }

    function renderLobby() {
      function createPlayerElement(p, source, index, isQueue = false) {
        const el = document.createElement('div');
        el.className = `player ${p.banned ? 'banned' : getColor(p.bhv)}`;
        el.draggable = !p.banned;
        if (!p.banned) {
          el.ondragstart = (e) => drag(e, source, index);
        }
        el.ondblclick = () => openEditModal(p, { source, index, isQueue });
        
        const actions = isQueue ? `
          <div class="queue-player-actions">
            <button onclick=\"addToTeam('${source}', ${index}, 'team1')\" ${p.banned ? 'disabled' : ''}>${currentLanguage === 'en' ? 'Team 1' : '–ö–æ–º–∞–Ω–¥–∞ 1'}</button>
            <button onclick=\"addToTeam('${source}', ${index}, 'team2')\" ${p.banned ? 'disabled' : ''}>${currentLanguage === 'en' ? 'Team 2' : '–ö–æ–º–∞–Ω–¥–∞ 2'}</button>
            <button onclick=\"kickPlayer('${source}', ${index}, ${isQueue})\">${currentLanguage === 'en' ? 'Kick' : '–£–¥–∞–ª–∏—Ç—å'}</button>
          </div>
        ` : `
          <div>
            <button onclick=\"kickPlayer('${source}', ${index}, ${isQueue})\">${currentLanguage === 'en' ? 'Kick' : '–£–¥–∞–ª–∏—Ç—å'}</button>
            <button onclick=\"moveToQueue('${source}', ${index})\" ${p.banned ? 'disabled' : ''}>${currentLanguage === 'en' ? 'To Queue' : '–í –æ—á–µ—Ä–µ–¥—å'}</button>
          </div>
        `;
        
        el.innerHTML = `
          <div>${p.name} | MMR: ${p.mmr} | BHV: ${p.bhv} ${p.banned ? '| BANNED' : ''}</div>
          ${actions}
        `;
        return el;
      }
      
      const lobby = lobbies[currentLobby];

      // Render teams
      ["team1", "team2"].forEach(team => {
        const div = document.getElementById(`${team}Players`);
        div.innerHTML = '';
        lobby[team].forEach((p, i) => {
          const el = createPlayerElement(p, team, i);
          div.appendChild(el);
        });

        // Update team count
        document.getElementById(`${team}Count`).textContent = lobby[team].length;

        const sum = arr => arr.reduce((sum, x) => sum + x, 0);
        const activePlayers = lobby[team].filter(p => !p.banned);
        const sumMMR = sum(activePlayers.map(p => p.mmr));
        const sumBHV = sum(activePlayers.map(p => p.bhv));
        const avgMMR = (sumMMR / (activePlayers.length || 1)).toFixed(1);
        const avgBHV = (sumBHV / (activePlayers.length || 1)).toFixed(1);
        
        const statsDiv = document.getElementById(`${team}Stats`);
        statsDiv.innerHTML = `
          <div class="team-stats">
            <span class="team-stat">Avg MMR: ${avgMMR}</span>
            <span class="team-stat">Avg BHV: ${avgBHV}</span>
            <span class="team-stat">Sum MMR: ${sumMMR}</span>
            <span class="team-stat">Sum BHV: ${sumBHV}</span>
          </div>
        `;
      });

      // Render queue
      const queueDiv = document.getElementById('waitingList');
      queueDiv.innerHTML = '';
      globalQueue.forEach((p, i) => {
        const el = createPlayerElement(p, 'queue', i, true);
        queueDiv.appendChild(el);
      });

      // Update queue count
      document.getElementById('queueCount').textContent = globalQueue.length;
    }

    function addToTeam(source, index, targetTeam) {
      if (source !== 'queue') return;
      
      const player = globalQueue.splice(index, 1)[0];
      
      // Check if player is banned
      if (player.banned) {
        alert(currentLanguage === 'en' ? "Banned players cannot be added to teams" : "–ó–∞–±–∞–Ω–µ–Ω–Ω—ã–µ –∏–≥—Ä–æ–∫–∏ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –∫–æ–º–∞–Ω–¥—ã");
        globalQueue.splice(index, 0, player); // Return to original position
        renderLobby();
        return;
      }
      
      lobbies[currentLobby][targetTeam].push(player);
      renderLobby();
      saveToLocalStorage();
    }

    function balanceTeams() {
      const lobby = lobbies[currentLobby];
      
      // Combine all players from both teams (excluding banned)
      let players = [...lobby.team1, ...lobby.team2].filter(p => !p.banned);
      
      // Reset teams
      lobby.team1 = [];
      lobby.team2 = [];
      
      // Sort by BHV first (ascending) then by MMR (descending)
      players.sort((a, b) => {
        if (a.bhv !== b.bhv) return a.bhv - b.bhv;
        return b.mmr - a.mmr;
      });
      
      // Try multiple balancing attempts to find the best distribution
      let bestDiff = Infinity;
      let bestTeam1 = [];
      let bestTeam2 = [];
      
      // Several attempts to find optimal balance
      for (let attempt = 0; attempt < 10; attempt++) {
        // Shuffle players slightly for different attempts
        if (attempt > 0) {
          players = shuffleArray(players);
        }
        
        const team1 = [];
        const team2 = [];
        let team1BHV = 0, team2BHV = 0;
        let team1MMR = 0, team2MMR = 0;
        
        // Distribute players
        for (const player of players) {
          // Calculate potential new totals
          const newTeam1BHV = team1BHV + player.bhv;
          const newTeam2BHV = team2BHV + player.bhv;
          const newTeam1MMR = team1MMR + player.mmr;
          const newTeam2MMR = team2MMR + player.mmr;
          
          // Calculate differences for both options
          const diffIfTeam1 = Math.abs(newTeam1BHV - team2BHV) + Math.abs(newTeam1MMR - team2MMR) * 0.5;
          const diffIfTeam2 = Math.abs(team1BHV - newTeam2BHV) + Math.abs(team1MMR - newTeam2MMR) * 0.5;
          
          // Choose the option that minimizes both BHV and MMR differences
          if (diffIfTeam1 < diffIfTeam2) {
            team1.push(player);
            team1BHV = newTeam1BHV;
            team1MMR = newTeam1MMR;
          } else {
            team2.push(player);
            team2BHV = newTeam2BHV;
            team2MMR = newTeam2MMR;
          }
        }
        
        // Calculate total difference for this attempt
        const bhvDiff = Math.abs(team1BHV - team2BHV);
        const mmrDiff = Math.abs(team1MMR - team2MMR);
        const totalDiff = bhvDiff + mmrDiff * 0.5; // Give more weight to BHV
        
        // Keep this distribution if it's better
        if (totalDiff < bestDiff) {
          bestDiff = totalDiff;
          bestTeam1 = [...team1];
          bestTeam2 = [...team2];
        }
      }
      
      // Apply the best found distribution
      lobby.team1 = bestTeam1;
      lobby.team2 = bestTeam2;
      
      // Keep banned players in their original teams
      const bannedPlayersTeam1 = lobbies[currentLobby].team1.filter(p => p.banned);
      const bannedPlayersTeam2 = lobbies[currentLobby].team2.filter(p => p.banned);
      lobby.team1.push(...bannedPlayersTeam1);
      lobby.team2.push(...bannedPlayersTeam2);
      
      renderLobby();
      saveToLocalStorage();
    }

    function createBestLobby() {
      if (globalQueue.length < 10) {
        alert(currentLanguage === 'en' ? "Need at least 10 players in queue to create a 5v5 lobby" : "–ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 10 –∏–≥—Ä–æ–∫–æ–≤ –≤ –æ—á–µ—Ä–µ–¥–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏ 5—Ö5");
        return;
      }

      // Get top 10 players by MMR
      const candidates = [...globalQueue]
        .filter(p => !p.banned)
        .sort((a, b) => b.mmr - a.mmr)
        .slice(0, Math.min(20, globalQueue.length)); // Take top 20 MMR players

      if (candidates.length < 10) {
        alert(currentLanguage === 'en' ? "Not enough unbanned players in queue to create a 5v5 lobby" : "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –Ω–µ–∑–∞–±–∞–Ω–µ–Ω–Ω—ã—Ö –∏–≥—Ä–æ–∫–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏ 5—Ö5");
        return;
      }

      // Find the most balanced 10 players group
      let bestGroup = [];
      let bestDiff = Infinity;

      // Try multiple random combinations to find the most balanced
      for (let i = 0; i < 100; i++) {
        const shuffled = shuffleArray([...candidates]);
        const group = shuffled.slice(0, 10);
        
        // Calculate MMR and BHV variance
        const mmrs = group.map(p => p.mmr);
        const bhvs = group.map(p => p.bhv);
        
        const mmrDiff = Math.max(...mmrs) - Math.min(...mmrs);
        const bhvDiff = Math.max(...bhvs) - Math.min(...bhvs);
        const totalDiff = mmrDiff * 0.5 + bhvDiff; // More weight to BHV
        
        if (totalDiff < bestDiff) {
          bestDiff = totalDiff;
          bestGroup = group;
        }
      }

      // Remove selected players from queue
      globalQueue = globalQueue.filter(p => !bestGroup.some(g => g.name === p.name));

      // Add to current lobby
      const lobby = lobbies[currentLobby];
      lobby.team1 = [];
      lobby.team2 = [];

      // Distribute players to teams
      bestGroup.sort((a, b) => b.mmr - a.mmr); // Sort by MMR descending
      bestGroup.forEach((p, i) => {
        if (i % 2 === 0) {
          lobby.team1.push(p);
        } else {
          lobby.team2.push(p);
        }
      });

      renderLobby();
      saveToLocalStorage();
    }

    function shuffleArray(array) {
      const newArray = [...array];
      for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
      }
      return newArray;
    }

    function kickPlayer(source, index, isQueue = false) {
      if (isQueue) {
        globalQueue.splice(index, 1);
      } else {
        lobbies[currentLobby][source].splice(index, 1);
      }
      renderLobby();
      saveToLocalStorage();
    }

    function moveToQueue(source, index) {
      const player = lobbies[currentLobby][source].splice(index, 1)[0];
      if (!player.banned) {
        globalQueue.push(player);
      }
      renderLobby();
      saveToLocalStorage();
    }

    function clearQueue() {
      if (confirm(currentLanguage === 'en' ? "Clear the queue? All players will be removed." : "–û—á–∏—Å—Ç–∏—Ç—å –æ—á–µ—Ä–µ–¥—å? –í—Å–µ –∏–≥—Ä–æ–∫–∏ –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã.")) {
        globalQueue = [];
        renderLobby();
        saveToLocalStorage();
      }
    }

    function searchPlayer() {
      updatePlayersList(document.getElementById("playerSearch").value.toLowerCase());
    }

    function sortPlayers(field, direction) {
      currentSort = { field, direction };
      updatePlayersList();
      
      // Update active sort button
      document.querySelectorAll('.sort-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.textContent.includes(field === 'name' ? 'Name' : 
                                     field === 'mmr' ? 'MMR' : 
                                     field === 'bhv' ? 'BHV' : '') &&
            btn.textContent.includes(direction === 'asc' ? 'A-Z' : 
                                    direction === 'asc' ? 'Low-High' : 
                                    direction === 'desc' ? 'Z-A' : 'High-Low')) {
          btn.classList.add('active');
        }
      });
    }

    function updatePlayersList(filter = "") {
      const listElement = document.getElementById("playersListContent");
      listElement.innerHTML = "";

      // Apply filters
      const hideInLobby = document.getElementById("hideInLobby").checked;
      const hideInQueue = document.getElementById("hideInQueue").checked;
      const hideOffline = document.getElementById("hideOffline").checked;
      const showBannedOnly = document.getElementById("showBannedOnly").checked;
      const bhvFilter1 = document.getElementById("bhvFilter1").checked;
      const bhvFilter2 = document.getElementById("bhvFilter2").checked;
      const bhvFilter3 = document.getElementById("bhvFilter3").checked;
      
      let filteredPlayers = allPlayers.filter(player => {
        const inLobby = lobbies.some(l => l.team1.concat(l.team2).some(p => p.name === player.name));
        const inQueue = globalQueue.some(p => p.name === player.name);
        const isOnline = inLobby || inQueue;
        
        // Apply BHV filters if any are active
        if (bhvFilter1 || bhvFilter2 || bhvFilter3) {
          const bhv = player.bhv;
          const matchesFilter = 
            (bhvFilter1 && bhv >= 0 && bhv < 5000) ||
            (bhvFilter2 && bhv >= 5000 && bhv < 7500) ||
            (bhvFilter3 && bhv >= 7500);
          
          if (!matchesFilter) return false;
        }
        
        if (showBannedOnly) return player.banned;
        if (hideInLobby && inLobby) return false;
        if (hideInQueue && inQueue) return false;
        if (hideOffline && !isOnline) return false;
        if (
          filter &&
          !player.name.toLowerCase().includes(filter) &&
          !(player.friendId && player.friendId.toLowerCase().includes(filter))
        ) return false;
        return true;
      });

      // Apply sorting
      filteredPlayers.sort((a, b) => {
        let valA, valB;
        
        if (currentSort.field === 'lastSeen') {
          valA = new Date(a.lastSeen || 0);
          valB = new Date(b.lastSeen || 0);
        } else {
          valA = a[currentSort.field];
          valB = b[currentSort.field];
        }
        
        if (typeof valA === 'string') valA = valA.toLowerCase();
        if (typeof valB === 'string') valB = valB.toLowerCase();
        
        if (valA < valB) return currentSort.direction === 'asc' ? -1 : 1;
        if (valA > valB) return currentSort.direction === 'asc' ? 1 : -1;
        return 0;
      });

      filteredPlayers.forEach((player) => {
        const status = getPlayerStatus(player);
        const statusClass = getStatusClass(status);
        
        const playerElement = document.createElement("div");
        playerElement.className = `player-list-item ${player.banned ? 'banned' : getColor(player.bhv)}`;
        playerElement.innerHTML = `
          <div>
            <strong>${player.name}</strong> 
            <span class="player-status ${statusClass}">${status}</span>
          </div>
          <div>MMR: ${player.mmr} | BHV: ${player.bhv}</div>
          <div class="player-actions">
            <button onclick="addPlayerToQueueFromList('${player.name}')" ${player.banned ? 'disabled' : ''}>${currentLanguage === 'en' ? 'Add to Queue' : '–í –æ—á–µ—Ä–µ–¥—å'}</button>
            <button onclick="openEditModal(${JSON.stringify(player)}, findPlayerLocation(${JSON.stringify(player)}))">${currentLanguage === 'en' ? 'Edit' : '–†–µ–¥.'}</button>
          </div>
        `;
        playerElement.ondblclick = () => {
          // Switch to the lobby where the player is located if in lobby
          for (let i = 0; i < lobbies.length; i++) {
            if (lobbies[i].team1.some(p => p.name === player.name) || lobbies[i].team2.some(p => p.name === player.name)) {
              if (i !== currentLobby) {
                switchLobby(i);
                showMainPage();
              }
              break;
            }
          }
          openEditModal(player, findPlayerLocation(player));
        };
        listElement.appendChild(playerElement);
      });
    }

    function addPlayerToQueueFromList(playerName) {
      const player = allPlayers.find(p => p.name === playerName);
      if (!player) return;

      if (player.banned) {
        alert(currentLanguage === 'en' ? "Banned players cannot be added to queue" : "–ó–∞–±–∞–Ω–µ–Ω–Ω—ã–µ –∏–≥—Ä–æ–∫–∏ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –æ—á–µ—Ä–µ–¥—å");
        return;
      }

      const alreadyInGame = lobbies.some(lobby =>
        lobby.team1.concat(lobby.team2).some(p => p.name === player.name)
      );
      if (alreadyInGame) {
        alert(currentLanguage === 'en' ? "Player is already in one of the lobbies" : "–ò–≥—Ä–æ–∫ —É–∂–µ –≤ –æ–¥–Ω–æ–º –∏–∑ –ª–æ–±–±–∏");
        return;
      }

      const alreadyInQueue = globalQueue.some(p => p.name === player.name);
      if (alreadyInQueue) {
        alert(currentLanguage === 'en' ? "Player is already in queue" : "–ò–≥—Ä–æ–∫ —É–∂–µ –≤ –æ—á–µ—Ä–µ–¥–∏");
        return;
      }

      globalQueue.unshift({...player});
      renderLobby();
      updatePlayersList();
      saveToLocalStorage();
    }

    function findPlayerLocation(player) {
      // Check if player is in queue
      const queueIndex = globalQueue.findIndex(p => p.name === player.name);
      if (queueIndex !== -1) {
        return { source: 'queue', index: queueIndex, isQueue: true };
      }
      
      // Check if player is in any lobby
      for (let i = 0; i < lobbies.length; i++) {
        const lobby = lobbies[i];
        for (const [source, players] of Object.entries(lobby)) {
          const index = players.findIndex(p => p.name === player.name);
          if (index !== -1) return { source, index, lobbyIndex: i };
        }
      }
      return null;
    }

    function openEditModal(player, location) {
      currentlyEditedPlayer = { player, location };
      document.getElementById("editName").value = player.name;
      document.getElementById("editMMR").value = player.mmr;
      document.getElementById("editBHV").value = player.bhv;
      document.getElementById("editFriendId").value = player.friendId || '';
      document.getElementById("editNote").value = player.note || "";
      
      const banButton = document.getElementById("banButton");
      if (player.banned) {
        banButton.textContent = currentLanguage === 'en' ? "Unban" : "–†–∞–∑–±–∞–Ω–∏—Ç—å";
        banButton.className = "success";
      } else {
        banButton.textContent = currentLanguage === 'en' ? "Ban" : "–ó–∞–±–∞–Ω–∏—Ç—å";
        banButton.className = "danger";
      }
      
      document.getElementById("editModal").style.display = "flex";
    }

    function toggleBanPlayer() {
      const { player } = currentlyEditedPlayer;
      player.banned = !player.banned;
      player.lastSeen = new Date().toLocaleDateString();
      
      // Update in allPlayers list
      const allPlayerIndex = allPlayers.findIndex(p => 
        p.name === player.name || (player.friendId && p.friendId === player.friendId)
      );
      if (allPlayerIndex !== -1) {
        allPlayers[allPlayerIndex].banned = player.banned;
        allPlayers[allPlayerIndex].lastSeen = player.lastSeen;
      }
      
      // Remove from queues/lobbies if banned
      if (player.banned) {
        // Remove from global queue
        globalQueue = globalQueue.filter(p => p.name !== player.name);
        
        // Remove from all lobbies
        lobbies.forEach(lobby => {
          lobby.team1 = lobby.team1.filter(p => p.name !== player.name);
          lobby.team2 = lobby.team2.filter(p => p.name !== player.name);
        });
      }
      
      saveToLocalStorage();
      renderLobby();
      updatePlayersList();
      closeModal();
    }

    function closeModal() {
      document.getElementById("editModal").style.display = "none";
    }

    function savePlayerChanges() {
      const name = document.getElementById("editName").value;
      const mmr = parseInt(document.getElementById("editMMR").value);
      const bhv = parseInt(document.getElementById("editBHV").value);
      const friendId = document.getElementById("editFriendId").value;
      const note = document.getElementById("editNote").value;

      if (!name || isNaN(mmr) || isNaN(bhv)) {
        alert(currentLanguage === 'en' ? "Please fill all fields correctly!" : "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ!");
        return;
      }

      const { player, location } = currentlyEditedPlayer;
      if (!location) return;

      // Check if friendId is already used by another player
      if (friendId && friendId !== player.friendId) {
        const existingPlayer = allPlayers.find(p => p.friendId === friendId && p.name !== player.name);
        if (existingPlayer) {
          alert(currentLanguage === 'en' ? "This Friend ID is already used by another player" : "–≠—Ç–æ—Ç Friend ID —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥—Ä—É–≥–∏–º –∏–≥—Ä–æ–∫–æ–º");
          return;
        }
      }

      // Update player data in all locations
      player.name = name;
      player.mmr = mmr;
      player.bhv = bhv;
      player.friendId = friendId;
      player.note = note;
      player.lastSeen = new Date().toLocaleDateString();

      // Update in allPlayers list
      const allPlayerIndex = allPlayers.findIndex(p => 
        p.name === player.name || (player.friendId && p.friendId === player.friendId)
      );
      if (allPlayerIndex !== -1) {
        allPlayers[allPlayerIndex] = {...player};
      } else {
        allPlayers.push({...player});
      }

      closeModal();
      renderLobby();
      updatePlayersList();
      saveToLocalStorage();
    }

    function clearCurrentLobby() {
      if (confirm(currentLanguage === 'en' ? "Clear the current lobby? All players will be moved to queue." : "–û—á–∏—Å—Ç–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –ª–æ–±–±–∏? –í—Å–µ –∏–≥—Ä–æ–∫–∏ –±—É–¥—É—Ç –ø–µ—Ä–µ–º–µ—â–µ–Ω—ã –≤ –æ—á–µ—Ä–µ–¥—å.")) {
        const lobby = lobbies[currentLobby];
        // Move only unbanned players to queue
        globalQueue.push(...lobby.team1.filter(p => !p.banned), ...lobby.team2.filter(p => !p.banned));
        lobby.team1 = [];
        lobby.team2 = [];
        renderLobby();
        saveToLocalStorage();
      }
    }

    function openSettingsModal() {
      document.getElementById("settingsModal").style.display = "flex";
      document.getElementById("languageSelect").value = currentLanguage;
    }

    function closeSettingsModal() {
      document.getElementById("settingsModal").style.display = "none";
    }

    function changeLanguage() {
      currentLanguage = document.getElementById("languageSelect").value;
      applyLanguage();
      saveToLocalStorage();
      closeSettingsModal();
    }

    function applyLanguage() {
      const lang = translations[currentLanguage];
      
      // Main page
      document.getElementById("mainTitle").textContent = lang.title;
      document.getElementById("name").placeholder = lang.nickname;
      document.getElementById("mmr").placeholder = lang.rating;
      document.getElementById("bhv").placeholder = lang.bhv;
      document.getElementById("friendId").placeholder = lang.friendId;
      document.getElementById("addToQueueBtn").textContent = lang.addToQueue;
      document.getElementById("moveAllBtn").textContent = lang.moveAllToLobby;
      document.getElementById("clearLobbyBtn").textContent = lang.clearLobby;
      document.getElementById("team1Title").innerHTML = `${lang.team1} <span class="team-count">(<span id="team1Count">0</span>/5)</span>`;
      document.getElementById("team2Title").innerHTML = `${lang.team2} <span class="team-count">(<span id="team2Count">0</span>/5)</span>`;
      document.getElementById("balanceBtn").textContent = lang.balanceTeams;
      document.getElementById("queueTitle").innerHTML = `${lang.globalQueue} <span class="team-count">(<span id="queueCount">0</span>)</span>`;
      document.getElementById("createLobbyBtn").textContent = lang.createLobby;
      document.getElementById("clearQueueBtn").textContent = lang.clearQueue;
      
      // All players page
      document.getElementById("allPlayersTitle").textContent = lang.allPlayers;
      document.getElementById("playerSearch").placeholder = `${lang.nickname}...`;
      document.getElementById("hideInLobbyLabel").textContent = lang.hideInLobby;
      document.getElementById("hideInQueueLabel").textContent = lang.hideInQueue;
      document.getElementById("hideOfflineLabel").textContent = lang.hideOffline;
      document.getElementById("showBannedLabel").textContent = lang.showBanned;
      document.getElementById("bhvFilter1Label").textContent = lang.bhvFilter1;
      document.getElementById("bhvFilter2Label").textContent = lang.bhvFilter2;
      document.getElementById("bhvFilter3Label").textContent = lang.bhvFilter3;
      document.getElementById("sortNameAsc").textContent = lang.sortNameAsc;
      document.getElementById("sortNameDesc").textContent = lang.sortNameDesc;
      document.getElementById("sortMmrAsc").textContent = lang.sortMmrAsc;
      document.getElementById("sortMmrDesc").textContent = lang.sortMmrDesc;
      document.getElementById("sortBhvAsc").textContent = lang.sortBhvAsc;
      document.getElementById("sortBhvDesc").textContent = lang.sortBhvDesc;
      document.getElementById("backToLobbyBtn").textContent = lang.backToLobby;
      
      // Edit modal
      document.getElementById("editPlayerTitle").textContent = lang.editPlayer;
      document.getElementById("editName").placeholder = lang.nickname;
      document.getElementById("savePlayerBtn").textContent = lang.save;
      document.getElementById("cancelEditBtn").textContent = lang.cancel;
      
      // Settings modal
      document.getElementById("settingsTitle").textContent = lang.settings;
      document.getElementById("languageLabel").textContent = lang.language;
      document.getElementById("closeSettingsBtn").textContent = lang.close;
      
      // Update ban button if modal is open
      if (document.getElementById("editModal").style.display === "flex" && currentlyEditedPlayer) {
        const banButton = document.getElementById("banButton");
        if (currentlyEditedPlayer.player.banned) {
          banButton.textContent = lang.unban;
          banButton.className = "success";
        } else {
          banButton.textContent = lang.ban;
          banButton.className = "danger";
        }
      }
      
      // Re-render UI to update language
      renderLobby();
      if (document.getElementById("allPlayersPage").style.display !== "none") {
        updatePlayersList();
      }
    }

    function saveToLocalStorage() {
      localStorage.setItem('dotaBalancerData', JSON.stringify({
        lobbies,
        globalQueue,
        allPlayers,
        currentLanguage
      }));
    }

    function loadFromLocalStorage() {
      const savedData = localStorage.getItem('dotaBalancerData');
      if (savedData) {
        const parsedData = JSON.parse(savedData);
        if (parsedData.lobbies) {
          parsedData.lobbies.forEach((lobby, index) => {
            lobbies[index] = lobby;
          });
        }
        if (parsedData.globalQueue) {
          globalQueue = parsedData.globalQueue;
        }
        if (parsedData.allPlayers) {
          allPlayers = parsedData.allPlayers;
        } else {
          // Migrate from old version
          allPlayers = [...globalQueue];
          lobbies.forEach(lobby => {
            allPlayers.push(...lobby.team1, ...lobby.team2);
          });
          // Remove duplicates
          allPlayers = allPlayers.filter((player, index, self) =>
            index === self.findIndex(p => p.name === player.name)
          );
        }
        if (parsedData.currentLanguage) {
          currentLanguage = parsedData.currentLanguage;
        }
        applyLanguage();
        renderLobby();
      }
    }

    window.onload = () => {
      loadFromLocalStorage();
      renderLobby();
    };
  </script>
  <div id="backgroundSelect">
  <label for="backgroundPicker">Background:</label>
  <select id="backgroundPicker" onchange="changeBackground()">
    <option value="dota2-background.jpg">Dota Static</option>
    <option value="dota2-background.gif">Dota Animated</option>
    <option value="red-blur">Red Blur</option>
    <option value="black-blur">Black Blur</option>
    <option value="white-blur">White Blur</option>
    <option value="starscape.jpg">Starscape</option>
    <option value="cyberpunk.jpg">Cyberpunk</option>
    <option value="gradient">Gradient Blur</option>
  </select>
</div>
<script>
  let players = []; // —Å–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤

  function downloadPlayers() {
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(allPlayers));
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", "players.json");
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    document.body.removeChild(downloadAnchorNode);
  }


  function loadPlayers(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const data = JSON.parse(e.target.result);
        if (Array.isArray(data)) {
          players = data;
          renderPlayerList(); // —Ç–≤–æ—è —Ñ—É–Ω–∫—Ü–∏—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
        } else {
          alert("–§–∞–π–ª –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤.");
        }
      } catch (err) {
        alert("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞: " + err.message);
      }
    };
    reader.readAsText(file);
  }

  function renderPlayerList() {
    const list = document.getElementById('playerList');
    list.innerHTML = '';
    let added = 0, skipped = 0;

    players.forEach(player => {
    if (typeof player.mmr === 'number' && typeof player.bhv === 'number') {
      const div = document.createElement('div');
      div.textContent = `${player.name} ‚Äî MMR: ${player.mmr}, BHV: ${player.bhv}`;
      list.appendChild(div);
      added++;

      // –î–æ–±–∞–≤–ª—è–µ–º –∏–≥—Ä–æ–∫–∞ –≤ allPlayers, –µ—Å–ª–∏ –µ–≥–æ —Ç–∞–º –µ—â—ë –Ω–µ—Ç
      const exists = allPlayers.find(p => p.name === player.name || (p.friendId && p.friendId === player.friendId));
      if (!exists) {
        allPlayers.push({...player});
      }
    } else {
      skipped++;
    }
    });

    // —Å–æ—Ö—Ä–∞–Ω—è–µ–º
    saveToLocalStorage();
    updatePlayersList(); // –æ–±–Ω–æ–≤–∏–º —Å–ø–∏—Å–æ–∫ All Players

    alert(`‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ –∏–≥—Ä–æ–∫–æ–≤: ${added}\n‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å: ${skipped}`);
  }
</script>
<script>
  function suggestBetterSwap() {
  const team1 = lobbies[currentLobby].team1.filter(p => !p.banned);
  const team2 = lobbies[currentLobby].team2.filter(p => !p.banned);

  let bestSwap = null;
  let bestDiff = Infinity;

  const calcTeamStats = (t1, t2) => {
    const sum = arr => arr.reduce((s, x) => s + x, 0);
    const t1MMR = sum(t1.map(p => p.mmr));
    const t2MMR = sum(t2.map(p => p.mmr));
    const t1BHV = sum(t1.map(p => p.bhv));
    const t2BHV = sum(t2.map(p => p.bhv));
    return Math.abs(t1MMR - t2MMR) + Math.abs(t1BHV - t2BHV);
  };

  for (let i = 0; i < team1.length; i++) {
    for (let j = 0; j < team2.length; j++) {
      const newTeam1 = [...team1];
      const newTeam2 = [...team2];
      [newTeam1[i], newTeam2[j]] = [newTeam2[j], newTeam1[i]];

      const diff = calcTeamStats(newTeam1, newTeam2);
      if (diff < bestDiff) {
        bestDiff = diff;
        bestSwap = [team1[i], team2[j]];
      }
    }
  }

  if (bestSwap) {
    alert(
      `üîÅ –ü—Ä–µ–¥–ª–∞–≥–∞–µ—Ç—Å—è –æ–±–º–µ–Ω:\n\n` +
      `‚û°Ô∏è ${bestSwap[0].name} (Team 1) ‚áÑ ${bestSwap[1].name} (Team 2)\n\n` +
      `‚öñÔ∏è –≠—Ç–æ —É–ª—É—á—à–∏—Ç –±–∞–ª–∞–Ω—Å MMR + BHV.`
    );
  } else {
    alert("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø–æ–¥—Ö–æ–¥—è—â—É—é –∑–∞–º–µ–Ω—É.");
  }
}
  function changeBackground() {
    const value = document.getElementById('backgroundPicker').value;
    const bgDiv = document.getElementById('dynamicBackground');

    if (value === 'red-blur') {
      bgDiv.style.background = 'radial-gradient(circle, rgba(255,0,0,0.6), rgba(0,0,0,0.8))';
      bgDiv.style.backgroundSize = 'cover';
    } else if (value === 'black-blur') {
      bgDiv.style.background = 'radial-gradient(circle, rgba(0,0,0,0.6), rgba(30,30,30,0.9))';
      bgDiv.style.backgroundSize = 'cover';
    } else if (value === 'white-blur') {
      bgDiv.style.background = 'radial-gradient(circle, rgba(255,255,255,0.6), rgba(200,200,200,0.9))';
      bgDiv.style.backgroundSize = 'cover';
    } else if (value === 'gradient') {
      bgDiv.style.background = 'linear-gradient(135deg, #1f4037, #99f2c8)';
      bgDiv.style.backgroundSize = 'cover';
      bgDiv.style.filter = 'blur(8px)';
    } else {
      bgDiv.style.background = `url('${value}') center/cover no-repeat`;
    }
  }
  
</script>
</body>
</html>
